<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F03%2FlongestPalindrome%2F</url>
    <content type="text"><![CDATA[title: longestPalindromedate: 2019-05-03 15:46:00categories: 题解tags: C++ String 回文串 algorithm 动态规划description:&lt;题解&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 –&gt;传送门示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 超时算法(滑动窗口算法，易于理解）：思路：从某一窗口长度开始，从0滑动到n-1的位置，判断子串是否为回文，再递增窗口长度。（窗口长度从1开始最一般，下面算法为从2开始） int check(string s) //判断是否为回文 { int n = s.size(); int k = n/2; if(k==0) { return 1; } else { int i=0,f=1; for(i; i&lt;k; i++) { if(s[i]!=s[n-i-1]) { f=0; break; } } if(f==1) { return 1; } else { return 0; } } } string longestPalindrome(string s) { int len = s.size(); if(len&lt;=1) { return s; } string str = &quot;&quot;; str+=s[0]; str+=s[1]; int f=0; for(int i=2; i&lt;len + 1; i++) { for(int j=0; j&lt;len-i+1 ; j++) { int k=0; string ss=&quot;&quot;; while(k&lt;i) //可用substr函数代替 { ss+=s[j+k]; k++; } if(check(ss)) { f=1; str = ss; break; } } } if(f==1) { return str; } str=&quot;&quot;; str+=s[0]; return str; } 正确O(n^2)时间复杂度算法：动态规划算法：思路：核心思想在于避免验证回文时的不必要的重复计算。从左往右验证，找出最长回文子串的开始与结束位置。递推公式为 P(i,j)=(s[i] == s[j]) &amp;&amp; (P[i-1][j+1])PS：需考虑字母数为偶数回文的特殊情况，和确定判断条件。 class Solution { public: string longestPalindrome(string s) { int len = s.size(); if(len &lt;= 1) return s; int left=0,right=0; int book[1000][1000]={0}; //1符合，0不符合 for(int i=0;i&lt;len;i++){ book[i][i]=1; //单个字母为回文 for(int j=i-1;j&gt;=0;j--){ book[i][j] = (s[i] == s[j]) &amp;&amp; (book[i-1][j+1] || i-j==1); //注意i-j==1条件不能少 //cout&lt;&lt;j&lt;&lt;&apos; &apos;&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;book[i][j]&lt;&lt;endl; if(book[i][j] &amp;&amp; (i-j)&gt;(right-left)){ left = j; right = i; } } } string longest=&quot;&quot;; longest=s.substr(left,right-left+1); return longest; } }; 中心扩展算法：思路：由于回文关于中心对称，所以回文可以从中心展开，其中，共有2*n-1个中心（考虑字母数为偶数的回文）难点：expandAroundCenter()函数的返回值计算与start和end位置的确定。 class Solution { public: string longestPalindrome(string s) { int len = s.size(); if(len&lt;=1) return s; int start=0,end=0; for(int i=0;i&lt;len;i++){ int len1 = expandAroundCenter(s,i,i); int len2 = expandAroundCenter(s,i,i+1); //cout&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;len1&lt;&lt;&apos; &apos;&lt;&lt;len2&lt;&lt;endl; int len = len1 &gt; len2?len1:len2; if(len &gt; end-start){ if(len==len1){ //进一步归纳，len==len2情况的计算符合所有情况 start = i-len/2; end = i + len/2; }else{ start=i- (len-1)/2; end=i + len/2; } } } string longest=&quot;&quot;; longest=s.substr(start,end-start+1); return longest; } int expandAroundCenter(string s,int left,int right){ while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp;s[left]==s[right]){ left--;right++; } return right-left-1; //注意长度不是right-left+1 } };]]></content>
  </entry>
  <entry>
    <title><![CDATA[lengthOfLongestSubstring]]></title>
    <url>%2F2019%2F05%2F02%2FlengthOfLongestSubstring%2F</url>
    <content type="text"><![CDATA[题目简述：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。–&gt;传送门示例 1： 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2： 输入: &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3： 输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 个人超时解法： class Solution { public: int max=0; int notBelong(string s,char c){ int f=1; for(int i=0;i&lt;s.size();i++){ if(c==s[i]){ f=0;break; } } if(f==1) return 1; else return 0; } int lengthOfLongestSubstring(string s) { if(s.size()==0) //当s的长度为0或1时的出错情况任意忽视 return 0; else if(s.size()==1) return 1; else { for(int i=0;i&lt;s.size()-1;i++){ string str=&quot;&quot;; str+=s[i]; for(int j=i+1;j&lt;s.size();j++){ if(notBelong(str,s[j])){ str+=s[j]; }else{ if(str.size()&gt;max) max=str.size(); break; } } if(str.size()&gt;max) max=str.size(); } return max; } } }; 思路(摘自力扣题解)：滑动窗口算法，窗口指由开始和结束索引i,j定义的一个集合。将子串存入一个容器，如果s[j]不包含于子串中，向右滑动索引j，即j++;如果s[j]包含于子串中，则i++，窗口缩小。其中，在j++之后，取ans和（j-i）的最大值，即在线得到子串长度的最大值。 class Solution { public: int lengthOfLongestSubstring(string s) { int n=s.size(); set&lt;char&gt; ss; int ans=0,i=0,j=0; while(i&lt;n &amp;&amp; j&lt;n){ if(find(ss.begin(),ss.end(),s[j])==ss.end()){ ss.insert(s[j++]); ans= ans&gt;(j-i)? ans: j-i; }else{ ss.erase(s[i++]); } } return ans; } }; map法优化：我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。如果s[j]在[i,j)范围内有与j’重复的字符，不是逐渐增加i，而是直接跳过[i,j’]的范围内的所有元素，将i变为j’+1。（注意取i和j’+1的较大值，eg：”abba”） class Solution { public: int lengthOfLongestSubstring(string s) { int n=s.size(); map&lt;char,int&gt; m; int ans =0; for(int j=0,i=0;j&lt;n;j++){ if(m.find(s[j])!=m.end()){ i= m[s[j]]&gt;i? m[s[j]]: i; } ans = ans &gt; (j-i+1)? ans : (j-i+1); m[s[j]]=j+1; } return ans; } };]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
